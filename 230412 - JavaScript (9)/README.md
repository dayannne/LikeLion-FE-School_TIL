# 오늘 공부한 내용 🌼

---

- 전개구문 복습
- 아규먼트
- roro기법
- 재귀함수
- 호이스팅
- 스코프
- 즉시 실행함수
- call by value
- 클로저
- 생성자 함수
- 콜백함수
- MAP

# 새로 알게된 내용 💡

---

## 전개구문

- 중첩 배열을 전개구문할 때엔 `flat()`을 사용해 중첩을 벗겨낸 후 전개구문으로!
  ```jsx
  Math.max(...[10, 20, 30, [11, 12, 13, [29, 40, 50]]].flat(Infinity));
  ```

## 함수

- 처음 function을 만들었을 때엔 function이라는 이름만 보고 지나쳐 갔다가, 호출되었을 때 타고 올라온다. 그리고 다시 내려와 코드를 실행한다.
- **파선아실** - 파라미터는 선언할 때 아규먼트는 실제 사용하는 값

### return문이 종료문으로

- return 문이 종료문처럼 활용이 되기도 한다.
  ```jsx
  function hello2() {
    console.log('hello');
    return;
  }
  ```

### 함수 dir에 접근해 값을 바꿀 수 있다?

```jsx
function 함수1(a, b) {
  return a + b;
}

함수1['location'] = 'jeju';
함수1['name'] = 'jejufunction';
console.dir(함수1);
```

- 바뀌지 않는 것도 있다.

```jsx
함수1['length'] = 5;
// length 값은 바뀌지 않았다.
```

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ecf5c64-ab09-40c9-bab8-75664524ea69/Untitled.png)

### 순서대로 돌아가는 아규먼트

- 아규먼트가 순서대로 들어가는 함수의 특성

  ```jsx
  function 함수(a = 10, b = 20, c = 30) {
    console.log(a);
  }

  함수(); //=> 60
  함수(100); // => 150
  함수(100, 200); // => 330 // c값이 디폴트 30으로 설정되어 있기 때문
  함수(100, 200, 300); // => 600
  함수((c = 300)); // 변수인자 지정에 상관없이 순서대로 들어가게 된다.
  // 300 + (b)20 + (c)30 //=> 350
  함수((a = 100), (c = 300)); // => 430
  ```

입력되는 아규먼트가 매우 많은 함수의 경우 호출하는 쪽에서 어떤 값이 들어가는지 명확히 알기 어렵고 읽기도 어렵다. 이를 위해 사용하는 기법이 있는데, 바로 **roro기법!**

### roro 기법

"Return Only Read Only” 함수에서 반환된 값을 **읽기 전용으로만 사용**하는 것

함수가 반환한 값을 다른 변수나 상수에 할당하거나 함수 인자로 전달할 때,
이 값을 읽기 전용으로만 사용하도록 하여 예상치 못한 값 변경이나 부수 효과를 방지하기 위함

- roro기법 사용 방법

```jsx
function 로그인정보({
  회원등급 = 'Gold',
  글쓰기 = true,
  글읽기 = true,
  채널관리 = true,
  백업 = '1주일 이내 가능',
  소셜로그인여부 = true,
}) {
  console.log(회원등급, 글쓰기, 글읽기, 채널관리, 백업, 소셜로그인여부);
}
```

함수의 파라미터에 객체구조분해 문법을 사용해 객체로 선언해 준 부분이 roro기법이 사용된 것!

이렇게 객체 내의 프로퍼티들을 key-value 형태로 전달해주면 함수를 호출할 때에도 이를 함수 내에서 객체구조분해 문법을 사용하여 매개변수에서 분할된 변수들에 자동으로 할당된다.

- 호출은 다음과 같다!

```jsx
// 호출 - 구조분해 할당
로그인정보({
  // 중간에 생략된 값도 있고, 변수 순서도 바뀐 상태
  회원등급: 'Silver',
  소셜로그인여부: false,
  백업: '3일 이내 가능',
});
```

위 호출 방식을 보면 `회원등급`, `소셜로그인여부`, `백업` 은 모두 프로퍼티들의 값만 전달하고,
이들의 순서도 원래 함수에서 선언된 순서와 다르지만 roro기법을 사용했기에 함수 내에서 정확한 변수명에 매칭되어 할당됩니다. 전달한 프로퍼티가 없는 것들은 기본값으로 설정이 되므로 호출 코드를 간결하게 작성할 수 있다.

### 재귀함수

함수가 자기 자신을 호출하는 것

- 재귀함수는 무한히 반복될 수 있기 때문에 재귀 호출이 멈출 수 있는 종료조건을 체크해야 한다!
- 반복문으로 구현할 수 있는 것은 재귀함수로 모두 구현 가능하지만, 실무에서는 반복문 사용을 권함~

1. **\*factorial** (5! == 5 _ 4 _ 3 _ 2 _ 1)\*

```jsx
function factorial (n){
	if (n <= 1) {
  // 종료조건이 없다면 무한반복됨!
	return n
	}
	return n * factorial(n-1)
} / 5 * 4 / (5*4)*3... / 5*4*3*2*1
```

```jsx
result = 1;
for (let i = 2; i < 6; i++) {
  result *= i;
}
result;
```

1. 누적합

재귀함수로도, for문으로도 구할 수 있지만 둘 다 비효율적이다.
(재귀함수는 참고만하고 실제 누적합을 구할 때에는 수학 수식을 사용하기🤙)

```jsx
const n = 1000;
console.log((n * (n + 1)) / 2);
```

```jsx
function sigma(n) {
  if (n <= 1) {
    // 종료조건이 없다면 무한반복됨!
    return n;
  }
  return n + sigma(n - 1);
}
sigma(1000);
```

```jsx
result = 0;
for (let i = 1; i < 1001; i++) {
  result += i;
}
result;
```

1. 문자열 뒤집기

```jsx
function reverse(txt) {
  if (txt.length <= 1) {
    return txt;
  }
  return reverse(txt.slice(1)) + txt[0];
}
reverse('hello world');
```

```jsx
result = '';
for (const i of 'hello world') {
  result = i + result;
}
result;
```

### 호이스팅

함수나 변수를 끌어올려 주는 것 처럼 보임

인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미한다.

```jsx
함수(10);

function 함수(x) {
  return x + 100;
}
```

let, const, class를 이용한 선언문은 일시적 사각지대(Temporal Dead Zone)라는것을 만들어서 호이스팅이 되었지만 안된 것처럼 동작하게 합니다.

<aside>
💡 **Temporal Dead Zone(TDZ)이란?**

코드상에 let, const로 선언된 변수와 상수는 **TDZ**(**T**emporal **D**ead **Z**one. 임시 접근 불가구역) 구역에 배치됩니다. 이 값들은 선언에 대한 초기화가 실행된 후에 TDZ에서 제거되어 사용 가능한 상태가 됩니다. TDZ는 말 그대로 접근이 불가능하기 때문에, 초기화 전에 TDZ에 배치된 변수에 접근하려고 하면 에러를 발생시키게 됩니다.

</aside>

### 스코프

스코프란 변수의 접근성과 생존 기간을 제어하는 ‘생존 범위’를 의미

**스코프의 종류**

1. 전역 스코프
   - 스크립트의 어디서든 접근이 가능하기 때문에 사용이 쉽습니다.
   - 타인과의 협업, 라이브러리 사용시 충돌의 가능성이 있습니다.
2. 함수 스코프
   - 함수 내부에서 정의된 변수와 매개변수는 함수 외부에서 접근할 수 없습니다.
   - 함수 내부에서 정의된 변수라면 함수의 어느 부분에서도 접근 할 수 있습니다.
3. 블록 스코프 (ES6)
   - 중괄호 안에서만 접근 가능합니다.
   - 블록 내부에 정의된 변수는 블록의 실행이 끝나면 해제됩니다.

### 즉시 실행함수

즉시 실행하고 외부에서 컨트롤 할 필요가 없는 함수

```jsx
// 익명 즉시 실행 함수
(function () {
  let a = 1;
  let b = 2;
  return a + b;
})();

// 기명 즉시 실행 함수
(function foo() {
  let a = 3;
  let b = 5;
  return a * b;
})();

foo(); // ReferenceError: foo is not defined
// 어차피 실행하지 못해서 의미가 없음.
// 메모리 효율적으로 관리하기 위해 바로 실행해야 하는 것들을 즉시 실행함수로 관리
```

### 스코프

### call by value*(값의 전달)*

- call by value : _아규먼트에 값이 넘어올 때 **복사한 값**이 넘어온다!_
- reference*(참조-주소값의 전달)* : _아규먼트에 값이 넘어올 때 주소값이 넘어온다! (주소값이 넘어왔으니 접근을 하면 원본이다!)_
- J**avaScript는 `call by value`만 존재합니다.** 객체자료형의 경우가 call by reference인 것 처럼 보이지만, 사실 주소가 넘어가는 것이 아니라 주소가 복사가 되어 넘어가기 때문입니다.
- 원시값은 파라미터에 복사한 값을 저장하고 참조타입은 파라미터에 참조 주소를 복사하여 저장합니다.

```jsx
let array = [100, 200, 300];

function test(a) {
  a[0] = 1000;
}

test(array);
array;
```

- call by ref가 없는 반례

```jsx
// 반례
var a = {};
function test(b) {
  b = 1000;
}

test(a); // -> undefined
```

다른 언어의 경우 call by ref로 동작하여 a의 값이 1000으로 바뀝니다.

- 원시값보다 덩치가 큰 배열이나 객체도 인자로써 옮겨질 때 값이 복제되어 전달되면 실행시간이 길어질 수 도 있을까요?
  → 주소값을 복사하니 실행시간이 길어지지 않습니다.
- 그럼 변수가 가리키고 있는 공간에 저장된 '값'이 전달된다...?
  → 저장된 값 XXXX, ‘주소값’이 복사됩니다.
- 메모리 주소를 복사해서 넘기기 때문에 새로운 주소가 할당된 경우에만 변경이 안된다

### 클로저

한걸음 클로저 내맘~한뼘 클로저 투유

클로저란 **폐쇠된 공간 안에 데이터에 접근하기 위한 테크닉**

좀 더 풀어서 얘기하자면, 외부 함수에 대한 접근 권한을 내부 함수에 위임함으로서 폐쇠된 공간 안의 데이터에 접근할 수 있도록 하는 테크닉입니다.

- 그러면 왜 사용할까요? **변수 은닉**과 **메모리 효율**, **코드 효율(또는 완전성)을 극대화**하기 위해 사용합니다.
- 함수 내부에서 선언해야 합니다. 호출된 위치는 상관 없습니다.

```jsx
function 제곱(x) {
  function 승수(y) {
    return y ** x;
  }
  return 승수;
}

// | 승수  | -> 승수안의 값을 생성하지 않고 승수 자체가 리턴됨

let 제곱2 = 제곱(2); // 2 제곱해주는 함수
let 제곱3 = 제곱(3); // 3 제곱해주는 함수
let 제곱4 = 제곱(4); // 4 제곱해주는 함수

제곱2(2); // 이 때 비로소 승수에 해당하는 메모리가 생성되고 값저장
```

```jsx
function makeAdder(x) {
  var y = 1;
  return function (z) {
    y = 100;
    return x + y + z;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);
//클로저에 x와 y의 환경이 저장됨

console.log(add5(2)); // 107 (x:5 + y:100 + z:2)
console.log(add10(2)); // 112 (x:10 + y:100 + z:2)
//함수 실행 시 클로저에 저장된 x, y값에 접근하여 값을 계산
//지역스코프에서 값을 찾고, 없으면 그 밖에 있는 스코프에서 찾고, 계속해서 찾아 올라가 전역 스코프까지 찾아보는 것을 스코프체이닝
//어려운 얘기로는 내부 렉시컬 환경에서 찾고 없으면 전역 렉시컬 환경에서 찾는다 얘기함.
//함수가 수행된 이후에도 상위함수의 렉시컬 환경에 접근 가능
```

```jsx
function 승수제조기() {
  let value = 0;
  function 승수() {
    return (++value) ** 2;
  }
  return 승수;
}

let 승 = 승수제조기();
승();
승();
승();
value; //출력할 수 없습니다. 은닉화가 된거죠.
```

### 생성자 함수

사용자 정의 객체를 생성할 때 사용되는 함수

- 일반 함수와 구분하기 위해 생성자 함수 이름 첫 글자는 대문자로 시작합니다.
- 반드시 `'new'` 연산자를 붙여 실행. `new` 연산자는 생성자 함수의 this 가 인스턴스를 바라보도록 만들어주는 역할을 한다.

```jsx
// 1)
let book = {
  책이름: 'JavaScript',
  책가격: 1000,
  저자: '홍길동',
  출판일: '2023.04.12',
};
let newBook = {};

newBook['책이름'] = 'JavaScript';
newBook['책가격'] = 100000;
newBook['저자'] = '홍길동';
newBook['출판일'] = '2023.04.12';\

// 2)
function Book(책이름, 책가격, 저자, 출판일){
    this.책이름 = 책이름
    this.책가격 = 책가격
    this.저자 = 저자
    this.출판일 = 출판일
}

let book1 = new Book('JS', 0, ['이호준'], '2099.10.30')
let book2 = new Book('Python', 100000, ['이호준'], '2099.11.30')
let book3 = new Book('React', 1000000, ['이호준'], '2099.12.30')

console.log(book1, book2, book3)
```

- 실제로 아래와 같이 동작!

```jsx
function Book(책이름, 책가격, 저자, 출판일) {
  // this = {}
  this.책이름 = 책이름;
  this.책가격 = 책가격;
  this.저자 = 저자;
  this.출판일 = 출판일;
  // return this
}
```

### 콜백함수

함수를 아규먼트로 전달해서 언젠가는 사용해줄게!

```jsx
// 콜백함수
// 함수를 아규먼트로 전달해서 언젠가는 사용해줄게!
function 가장작은값에두배(a, b) {
  console.log(a);
  return b(...a);
}

가장작은값에두배([10, 20, 11, 21, 19.17], Math.min);

let arr = [10, 20, 11, 21, 19, 17];
arr.map((v, i) => v * 2);

let arr2 = [10, 20, 11, 21, 19, 17];
function 두배(x) {
  어쩔티비곱하기티비;
}

arr.map(두배);
```

### MAP

Map 객체는 키-값 쌍을 가지는 객체 자료형의 한 종류

```jsx
let m = new Map();

// Map에 값을 넣기
m.set('하나', '1');
m.set(1, '하나');
m.set(true, 1);
m.set(false, 0);
// => Map(4) { '하나' => 1, 1 => '하나', true => 1, false => 0 }

// Map의 값에 접근하기
console.log(m.get('하나'));
console.log(m.get(true));

// Map의 값이 있는지 확인하기
console.log(m.has('하나'));

// Map의 값을 제거하기
console.log(m.delete('하나'));
console.log(m.has('하나'));
console.log(m);

// Map의 크기를 확인하기
console.log(m.size);
```

<aside>
💡 **[1,2,3] != [1,2,3]**

```jsx
m.set([1, 2, 3], '리얼리');
m.get([1, 2, 3]); // undefined // [1,2,3] != [1,2,3] 주소값이 달라서
```

왜 undefind가 나오는 걸까?
⇒ [1,2,3] != [1,2,3] 주소값이 다르기 때문!

m.get([1, 2, 3])와 같은 코드는 [1, 2, 3]이라는 새로운 배열 객체를 생성하고, 이를 키 값으로 사용하여 Map에서 값을 가져오려 하기 때문에 undefined가 반환됩니다.

</aside>

- Map 의 여러가지 활용법

  - Map의 순환(일반적인 for문을 사용하려면 아래처럼 전개해야 합니다.)

    ```jsx
    // let m = [...data]
    for (const variable of m) {
      console.log(`m을 순회하고 있습니다. ${variable[0]}`);
      console.log(`m을 순회하고 있습니다. ${variable[1]}`);
    }

    for (const [key, val] of m) {
      console.log(`${key}: ${val}`);
    }
    ```

  - Map의 값에 접근
    ```jsx
    console.log(m.keys());
    console.log(m.values());
    console.log(m.entries());
    ```

# 오늘의 문제 ⚠️

---

```jsx
function 로그인정보({
  회원등급 = 'Gold',
  글쓰기 = true,
  글읽기 = true,
  채널관리 = true,
  백업 = '1주일 이내 가능',
  소셜로그인여부 = true,
}) {
  console.log(회원등급, 글쓰기, 글읽기, 채널관리, 백업, 소셜로그인여부);
}
```

```jsx
// 호출 - 구조분해 할당
로그인정보({
  // 중간에 생략된 값도 있고, 변수 순서도 바뀐 상태
  회원등급: 'Silver',
  소셜로그인여부: false,
  백업: '3일 이내 가능',
});
```

- `**로그인정보({})` 로 호출 했을 때에는 error가 안나지만
  `로그인정보()`호출했을 경우에는 error가 난다?!\*\*
  <aside>
  💡 빈 객체 **`{}`**를 전달하지 않은 경우에는 기본값이 지정되어 있어 에러가 발생하지 않는다.
  하지만 함수를 호출할 때 인자를 생략하고 그냥 **`로그인정보()`**와 같이 호출하는 경우에는 기본값도 없으므로 에러가 발생하게 된다.

      </aside>
